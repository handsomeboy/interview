## 面试题31：连续子数组的最大和



题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18 。



**解法一：举例分析数组的规律：**

我们试着从头尾逐个累加示例数组中的每个数字。初始化和为0.第一步加上第一个数字，此时和为1.接下来第二步加上数字-2，和就编程了-1.第三步加上数字3.我们注意到由于此前累计的和为-1，小于0，那如果用-1加3，得到的和为2，比3本身还小。也就是说从第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和。因此我们不用考虑从第一个子数组，之前累计的和也被抛弃。

我们从第三个数字重新开始累加，此时得到的和为3.接下来第四步加10，得到和为13.第五步加上-4，和为9.我们发现-4是一个负数，因此累加-4之后得到的和比原来的还小。因此我们要把之前得到的和13保存下来，它有可能是最大的子数组的和。第六步加上数字7，9加7的结果是16，此时和比之前最大的和13还要大，把最大的子数组的和由13更新为16.第七步加上2，累加得到的和为18，同时我们也要更新最大子数组的和。第八步加上最后一个数字-5，由于得到结果为13，小于此前得到的最大和18，因此最终最大的子数组的和为18，对应的子数组是｛3，10，-4，7，2｝。

实现代码：
```java
public int FindGreatestSumOfSubArray(int[] array) {

    // 参数校验
    if (array == null || array.length < 1) {
        return 0;
    }

    // 记录最大的子数组和，开始时是最小的整数
    int max = Integer.MIN_VALUE;

    // 当前的和
    int curMax = 0;
    for (int i : array) {
        // 如果当前和小于等于0，就重新设置当前和
        if (curMax < 0) {
            curMax = i;
        } else {
            // 如果当前和大于0，累加当前和
            curMax += i;
        }

        // 更新记录到的最在的子数组和
        if (max < curMax) {
            max = curMax;
        }
    }
    return max;
}
```

**解法二：应用动态规划法**
我们还可以适用动态规划的思想来分析这个问题。如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)]，其中0<=i<n。我们可以使用能够下面的递归公示求f(i):


```
     |pData[i]          i=0或者F(i-1)<0
F(i)=|
     |F(i-1)+pData[i]   i!=0或者F(i-1)>0
```

这个公式的意义：当以第i-1个数字结尾的子数组中所有的数字的和小于0时，如果把这个负数与第i个数累加，得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1个数字结尾的子数组中所有的数字的和大于0，与第i个数字累加就得到以第i个数字结尾的子数组中所有的数字的和。

虽然我们用递归的方法分析动态规划的问题，但最终都会基于循环去编码。



也可以这么理解:
F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变
F（i）=max（F（i-1）+array[i] ， array[i]）
res：所有子数组的和的最大值
res=max（res，F（i））

如数组[6, -3, -2, 7, -15, 1, 2, 2]
初始状态：
```
F（0）=6
res=6
``` 

i=1：
```
F（1）=max（F（0）-3，-3）=max（6-3，3）=3
res=max（F（1），res）=max（3，6）=6
```

i=2：
```
F（2）=max（F（1）-2，-2）=max（3-2，-2）=1
res=max（F（2），res）=max（1，6）=6
```
i=3：
```
F（3）=max（F（2）+7，7）=max（1+7，7）=8
res=max（F（2），res）=max（8，6）=8
```
i=4：
```
F（4）=max（F（3）-15，-15）=max（8-15，-15）=-7
res=max（F（4），res）=max（-7，8）=8
```
以此类推
最终res的值为8

所以顺理成章的实现代码为：
```java
public  int FindGreatestSumOfSubArray(int[] array) {
    int res = array[0]; //记录当前所有子数组的和的最大值
    int max=array[0];   //包含array[i]的连续数组最大值
    for (int i = 1; i < array.length; i++) {
        max=Math.max(max+array[i], array[i]);
        res=Math.max(max, res);
    }
    return res;
}
```


